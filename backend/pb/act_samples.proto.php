<?php
// Generated by https://github.com/bramp/protoc-gen-php// Please include protocolbuffers before this file, for example:
//   require('protocolbuffers.inc.php');
//   require('act_samples.proto.php');

namespace data {

  use Protobuf;
  use ProtobufEnum;
  use ProtobufMessage;

  require_once('types.proto.php');

  // message data.PbSportInfo
  final class PbSportInfo extends ProtobufMessage {

    private $_unknown;
    private $factor = null; // required float factor = 1
    private $timeStamp = null; // required .PbLocalDateTime time_stamp = 2
    private $sportProfileId = null; // optional uint64 sport_profile_id = 3

    public function __construct($in = null, &$limit = PHP_INT_MAX) {
      parent::__construct($in, $limit);
    }

    public function read($fp, &$limit = PHP_INT_MAX) {
      $fp = \ProtobufIO::toStream($fp, $limit);
      while(!feof($fp) && $limit > 0) {
        $tag = Protobuf::read_varint($fp, $limit);
        if ($tag === false) break;
        $wire  = $tag & 0x07;
        $field = $tag >> 3;
        switch($field) {
          case 1: // required float factor = 1
            if($wire !== 5) {
              throw new \Exception("Incorrect wire format for field $field, expected: 5 got: $wire");
            }
            $tmp = Protobuf::read_float($fp, $limit);
            if ($tmp === false) throw new \Exception('Protobuf::read_float returned false');
            $this->factor = $tmp;

            break;
          case 2: // required .PbLocalDateTime time_stamp = 2
            if($wire !== 2) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
            }
            $len = Protobuf::read_varint($fp, $limit);
            if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
            $limit -= $len;
            $this->timeStamp = new \PbLocalDateTime($fp, $len);
            if ($len !== 0) throw new \Exception('new PbLocalDateTime did not read the full length');

            break;
          case 3: // optional uint64 sport_profile_id = 3
            if($wire !== 0) {
              throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
            }
            $tmp = Protobuf::read_varint($fp, $limit);
            if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
            if ($tmp < Protobuf::MIN_UINT64 || $tmp > Protobuf::MAX_UINT64) throw new \Exception('uint64 out of range');$this->sportProfileId = $tmp;

            break;
          default:
            $limit -= Protobuf::skip_field($fp, $wire);
        }
      }
      if (!$this->validate()) throw new \Exception('Required fields are missing');
    }

    public function write($fp) {
      if (!$this->validate())
        throw new \Exception('Required fields are missing');
      if (!is_null($this->factor)) {
        fwrite($fp, "\x0d", 1);
        Protobuf::write_float($fp, $this->factor);
      }
      if (!is_null($this->timeStamp)) {
        fwrite($fp, "\x12", 1);
        Protobuf::write_varint($fp, $this->timeStamp->size());
        $this->timeStamp->write($fp);
      }
      if (!is_null($this->sportProfileId)) {
        fwrite($fp, "\x18", 1);
        Protobuf::write_varint($fp, $this->sportProfileId);
      }
    }

    public function size() {
      $size = 0;
      if (!is_null($this->factor)) {
        $size += 5;
      }
      if (!is_null($this->timeStamp)) {
        $l = $this->timeStamp->size();
        $size += 1 + Protobuf::size_varint($l) + $l;
      }
      if (!is_null($this->sportProfileId)) {
        $size += 1 + Protobuf::size_varint($this->sportProfileId);
      }
      return $size;
    }

    public function validate() {
      if ($this->factor === null) return false;
      if ($this->timeStamp === null) return false;
      return true;
    }

    public function clearFactor() { $this->factor = null; }
    public function hasFactor() { return $this->factor !== null; }
    public function getFactor() { if($this->factor !== null) return $this->factor; else return 0;}
    public function setFactor($value) { $this->factor = $value; }

    public function clearTimeStamp() { $this->timeStamp = null; }
    public function hasTimeStamp() { return $this->timeStamp !== null; }
    public function getTimeStamp() { if($this->timeStamp !== null) return $this->timeStamp; else return null;}
    public function setTimeStamp(PbLocalDateTime $value) { $this->timeStamp = $value; }

    public function clearSportProfileId() { $this->sportProfileId = null; }
    public function hasSportProfileId() { return $this->sportProfileId !== null; }
    public function getSportProfileId() { if($this->sportProfileId !== null) return $this->sportProfileId; else return 0;}
    public function setSportProfileId($value) { $this->sportProfileId = $value; }

    public function __toString() {
      return ''
           . Protobuf::toString('factor', $this->factor, 0)
           . Protobuf::toString('time_stamp', $this->timeStamp, null)
           . Protobuf::toString('sport_profile_id', $this->sportProfileId, 0);
    }

    // @@protoc_insertion_point(class_scope:data.PbSportInfo)
  }

  // enum data.PbActivityInfo.ActivityClass
  abstract class PbActivityInfo_ActivityClass extends ProtobufEnum {
    const SLEEP = 1;
    const SEDENTARY = 2;
    const LIGHT = 3;
    const CONTINUOUS_MODERATE = 4;
    const INTERMITTENT_MODERATE = 5;
    const CONTINUOUS_VIGOROUS = 6;
    const INTERMITTENT_VIGOROUS = 7;
    const NON_WEAR = 8;

    public static $_values = array(
      1 => "SLEEP",
      2 => "SEDENTARY",
      3 => "LIGHT",
      4 => "CONTINUOUS_MODERATE",
      5 => "INTERMITTENT_MODERATE",
      6 => "CONTINUOUS_VIGOROUS",
      7 => "INTERMITTENT_VIGOROUS",
      8 => "NON_WEAR",
    );

    public static function isValid($value) {
      return array_key_exists($value, self::$_values);
    }

    public static function toString($value) {
      checkArgument(is_int($value), 'value must be a integer');
      if (array_key_exists($value, self::$_values))
        return self::$_values[$value];
      return 'UNKNOWN';
    }
  }

  // message data.PbActivityInfo
  final class PbActivityInfo extends ProtobufMessage {

    private $_unknown;
    private $value = null; // required .data.PbActivityInfo.ActivityClass value = 1
    private $timeStamp = null; // required .PbLocalDateTime time_stamp = 2
    private $factor = null; // optional float factor = 3

    public function __construct($in = null, &$limit = PHP_INT_MAX) {
      parent::__construct($in, $limit);
    }

    public function read($fp, &$limit = PHP_INT_MAX) {
      $fp = \ProtobufIO::toStream($fp, $limit);
      while(!feof($fp) && $limit > 0) {
        $tag = Protobuf::read_varint($fp, $limit);
        if ($tag === false) break;
        $wire  = $tag & 0x07;
        $field = $tag >> 3;
        switch($field) {
          case 1: // required .data.PbActivityInfo.ActivityClass value = 1
            if($wire !== 0) {
              throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
            }
            $tmp = Protobuf::read_varint($fp, $limit);
            if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
            $this->value = $tmp;

            break;
          case 2: // required .PbLocalDateTime time_stamp = 2
            if($wire !== 2) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
            }
            $len = Protobuf::read_varint($fp, $limit);
            if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
            $limit -= $len;
            $this->timeStamp = new \PbLocalDateTime($fp, $len);
            if ($len !== 0) throw new \Exception('new PbLocalDateTime did not read the full length');

            break;
          case 3: // optional float factor = 3
            if($wire !== 5) {
              throw new \Exception("Incorrect wire format for field $field, expected: 5 got: $wire");
            }
            $tmp = Protobuf::read_float($fp, $limit);
            if ($tmp === false) throw new \Exception('Protobuf::read_float returned false');
            $this->factor = $tmp;

            break;
          default:
            $limit -= Protobuf::skip_field($fp, $wire);
        }
      }
      if (!$this->validate()) throw new \Exception('Required fields are missing');
    }

    public function write($fp) {
      if (!$this->validate())
        throw new \Exception('Required fields are missing');
      if (!is_null($this->value)) {
        fwrite($fp, "\x08", 1);
        Protobuf::write_varint($fp, $this->value);
      }
      if (!is_null($this->timeStamp)) {
        fwrite($fp, "\x12", 1);
        Protobuf::write_varint($fp, $this->timeStamp->size());
        $this->timeStamp->write($fp);
      }
      if (!is_null($this->factor)) {
        fwrite($fp, "\x1d", 1);
        Protobuf::write_float($fp, $this->factor);
      }
    }

    public function size() {
      $size = 0;
      if (!is_null($this->value)) {
        $size += 1 + Protobuf::size_varint($this->value);
      }
      if (!is_null($this->timeStamp)) {
        $l = $this->timeStamp->size();
        $size += 1 + Protobuf::size_varint($l) + $l;
      }
      if (!is_null($this->factor)) {
        $size += 5;
      }
      return $size;
    }

    public function validate() {
      if ($this->value === null) return false;
      if ($this->timeStamp === null) return false;
      return true;
    }

    public function clearValue() { $this->value = null; }
    public function hasValue() { return $this->value !== null; }
    public function getValue() { if($this->value !== null) return $this->value; else return PbActivityInfo_ActivityClass::SLEEP;}
    public function setValue($value) { $this->value = $value; }

    public function clearTimeStamp() { $this->timeStamp = null; }
    public function hasTimeStamp() { return $this->timeStamp !== null; }
    public function getTimeStamp() { if($this->timeStamp !== null) return $this->timeStamp; else return null;}
    public function setTimeStamp(PbLocalDateTime $value) { $this->timeStamp = $value; }

    public function clearFactor() { $this->factor = null; }
    public function hasFactor() { return $this->factor !== null; }
    public function getFactor() { if($this->factor !== null) return $this->factor; else return 0;}
    public function setFactor($value) { $this->factor = $value; }

    public function __toString() {
      return ''
           . Protobuf::toString('value', $this->value, PbActivityInfo_ActivityClass::SLEEP)
           . Protobuf::toString('time_stamp', $this->timeStamp, null)
           . Protobuf::toString('factor', $this->factor, 0);
    }

    // @@protoc_insertion_point(class_scope:data.PbActivityInfo)
  }

  // message data.PbInActivityTriggerInfo
  final class PbInActivityTriggerInfo extends ProtobufMessage {

    private $_unknown;
    private $timeStamp = null; // required .PbLocalDateTime time_stamp = 1

    public function __construct($in = null, &$limit = PHP_INT_MAX) {
      parent::__construct($in, $limit);
    }

    public function read($fp, &$limit = PHP_INT_MAX) {
      $fp = \ProtobufIO::toStream($fp, $limit);
      while(!feof($fp) && $limit > 0) {
        $tag = Protobuf::read_varint($fp, $limit);
        if ($tag === false) break;
        $wire  = $tag & 0x07;
        $field = $tag >> 3;
        switch($field) {
          case 1: // required .PbLocalDateTime time_stamp = 1
            if($wire !== 2) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
            }
            $len = Protobuf::read_varint($fp, $limit);
            if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
            $limit -= $len;
            $this->timeStamp = new \PbLocalDateTime($fp, $len);
            if ($len !== 0) throw new \Exception('new PbLocalDateTime did not read the full length');

            break;
          default:
            $limit -= Protobuf::skip_field($fp, $wire);
        }
      }
      if (!$this->validate()) throw new \Exception('Required fields are missing');
    }

    public function write($fp) {
      if (!$this->validate())
        throw new \Exception('Required fields are missing');
      if (!is_null($this->timeStamp)) {
        fwrite($fp, "\x0a", 1);
        Protobuf::write_varint($fp, $this->timeStamp->size());
        $this->timeStamp->write($fp);
      }
    }

    public function size() {
      $size = 0;
      if (!is_null($this->timeStamp)) {
        $l = $this->timeStamp->size();
        $size += 1 + Protobuf::size_varint($l) + $l;
      }
      return $size;
    }

    public function validate() {
      if ($this->timeStamp === null) return false;
      return true;
    }

    public function clearTimeStamp() { $this->timeStamp = null; }
    public function hasTimeStamp() { return $this->timeStamp !== null; }
    public function getTimeStamp() { if($this->timeStamp !== null) return $this->timeStamp; else return null;}
    public function setTimeStamp(PbLocalDateTime $value) { $this->timeStamp = $value; }

    public function __toString() {
      return ''
           . Protobuf::toString('time_stamp', $this->timeStamp, null);
    }

    // @@protoc_insertion_point(class_scope:data.PbInActivityTriggerInfo)
  }

  // message data.PbInActivityNonWearTriggerInfo
  final class PbInActivityNonWearTriggerInfo extends ProtobufMessage {

    private $_unknown;
    private $startTimeStamp = null; // required .PbLocalDateTime start_time_stamp = 1
    private $endTimeStamp = null; // required .PbLocalDateTime end_time_stamp = 2

    public function __construct($in = null, &$limit = PHP_INT_MAX) {
      parent::__construct($in, $limit);
    }

    public function read($fp, &$limit = PHP_INT_MAX) {
      $fp = ProtobufIO::toStream($fp, $limit);
      while(!feof($fp) && $limit > 0) {
        $tag = Protobuf::read_varint($fp, $limit);
        if ($tag === false) break;
        $wire  = $tag & 0x07;
        $field = $tag >> 3;
        switch($field) {
          case 1: // required .PbLocalDateTime start_time_stamp = 1
            if($wire !== 2) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
            }
            $len = Protobuf::read_varint($fp, $limit);
            if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
            $limit -= $len;
            $this->startTimeStamp = new PbLocalDateTime($fp, $len);
            if ($len !== 0) throw new \Exception('new PbLocalDateTime did not read the full length');

            break;
          case 2: // required .PbLocalDateTime end_time_stamp = 2
            if($wire !== 2) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
            }
            $len = Protobuf::read_varint($fp, $limit);
            if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
            $limit -= $len;
            $this->endTimeStamp = new PbLocalDateTime($fp, $len);
            if ($len !== 0) throw new \Exception('new PbLocalDateTime did not read the full length');

            break;
          default:
            $limit -= Protobuf::skip_field($fp, $wire);
        }
      }
      if (!$this->validate()) throw new \Exception('Required fields are missing');
    }

    public function write($fp) {
      if (!$this->validate())
        throw new \Exception('Required fields are missing');
      if (!is_null($this->startTimeStamp)) {
        fwrite($fp, "\x0a", 1);
        Protobuf::write_varint($fp, $this->startTimeStamp->size());
        $this->startTimeStamp->write($fp);
      }
      if (!is_null($this->endTimeStamp)) {
        fwrite($fp, "\x12", 1);
        Protobuf::write_varint($fp, $this->endTimeStamp->size());
        $this->endTimeStamp->write($fp);
      }
    }

    public function size() {
      $size = 0;
      if (!is_null($this->startTimeStamp)) {
        $l = $this->startTimeStamp->size();
        $size += 1 + Protobuf::size_varint($l) + $l;
      }
      if (!is_null($this->endTimeStamp)) {
        $l = $this->endTimeStamp->size();
        $size += 1 + Protobuf::size_varint($l) + $l;
      }
      return $size;
    }

    public function validate() {
      if ($this->startTimeStamp === null) return false;
      if ($this->endTimeStamp === null) return false;
      return true;
    }

    public function clearStartTimeStamp() { $this->startTimeStamp = null; }
    public function hasStartTimeStamp() { return $this->startTimeStamp !== null; }
    public function getStartTimeStamp() { if($this->startTimeStamp !== null) return $this->startTimeStamp; else return null;}
    public function setStartTimeStamp(PbLocalDateTime $value) { $this->startTimeStamp = $value; }

    public function clearEndTimeStamp() { $this->endTimeStamp = null; }
    public function hasEndTimeStamp() { return $this->endTimeStamp !== null; }
    public function getEndTimeStamp() { if($this->endTimeStamp !== null) return $this->endTimeStamp; else return null;}
    public function setEndTimeStamp(PbLocalDateTime $value) { $this->endTimeStamp = $value; }

    public function __toString() {
      return ''
           . Protobuf::toString('start_time_stamp', $this->startTimeStamp, null)
           . Protobuf::toString('end_time_stamp', $this->endTimeStamp, null);
    }

    // @@protoc_insertion_point(class_scope:data.PbInActivityNonWearTriggerInfo)
  }

  // message data.PbActivitySamples
  final class PbActivitySamples extends ProtobufMessage {

    private $_unknown;
    private $startTime = null; // required .PbLocalDateTime start_time = 1
    private $metRecordingInterval = null; // required .PbDuration met_recording_interval = 2
    private $stepsRecordingInterval = null; // required .PbDuration steps_recording_interval = 3
    private $metSamples = array(); // repeated float met_samples = 4
    private $stepsSamples = array(); // repeated uint32 steps_samples = 5
    private $sportInfo = array(); // repeated .data.PbSportInfo sport_info = 6
    private $activityInfo = array(); // repeated .data.PbActivityInfo activity_info = 7
    private $inactivityTrigger = array(); // repeated .data.PbInActivityTriggerInfo inactivity_trigger = 8
    private $inactivityNonWearTrigger = array(); // repeated .data.PbInActivityNonWearTriggerInfo inactivity_non_wear_trigger = 9

    public function __construct($in = null, &$limit = PHP_INT_MAX) {
      parent::__construct($in, $limit);
    }

    public function read($fp, &$limit = PHP_INT_MAX) {
      $fp = \ProtobufIO::toStream($fp, $limit);
      while(!feof($fp) && $limit > 0) {
        $tag = Protobuf::read_varint($fp, $limit);
        if ($tag === false) break;
        $wire  = $tag & 0x07;
        $field = $tag >> 3;
        switch($field) {
          case 1: // required .PbLocalDateTime start_time = 1
            if($wire !== 2) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
            }
            $len = Protobuf::read_varint($fp, $limit);
            if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
            $limit -= $len;
            $this->startTime = new \PbLocalDateTime($fp, $len);
            if ($len !== 0) throw new \Exception('new PbLocalDateTime did not read the full length');

            break;
          case 2: // required .PbDuration met_recording_interval = 2
            if($wire !== 2) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
            }
            $len = Protobuf::read_varint($fp, $limit);
            if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
            $limit -= $len;
            $this->metRecordingInterval = new \PbDuration($fp, $len);
            if ($len !== 0) throw new \Exception('new PbDuration did not read the full length');

            break;
          case 3: // required .PbDuration steps_recording_interval = 3
            if($wire !== 2) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
            }
            $len = Protobuf::read_varint($fp, $limit);
            if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
            $limit -= $len;
            $this->stepsRecordingInterval = new \PbDuration($fp, $len);
            if ($len !== 0) throw new \Exception('new PbDuration did not read the full length');

            break;
          case 4: // repeated float met_samples = 4
            if($wire !== 2 && $wire !== 5) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 or 5 got: $wire");
            }
            if ($wire === 5) {
              $tmp = Protobuf::read_float($fp, $limit);
              if ($tmp === false) throw new \Exception('Protobuf::read_float returned false');
              $this->metSamples[] = $tmp;
            } elseif ($wire === 2) {
              $len = Protobuf::read_varint($fp, $limit);
              while ($len > 0) {
                $tmp = Protobuf::read_float($fp, $len);
                if ($tmp === false) throw new \Exception('Protobuf::read_float returned false');
                $this->metSamples[] = $tmp;
              }
            }

            break;
          case 5: // repeated uint32 steps_samples = 5
            if($wire !== 2 && $wire !== 0) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 or 0 got: $wire");
            }
            if ($wire === 0) {
              $tmp = Protobuf::read_varint($fp, $limit);
              if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
              if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->stepsSamples[] = $tmp;
            } elseif ($wire === 2) {
              $len = Protobuf::read_varint($fp, $limit);
              while ($len > 0) {
                $tmp = Protobuf::read_varint($fp, $len);
                if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
                if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->stepsSamples[] = $tmp;
              }
            }

            break;
          case 6: // repeated .data.PbSportInfo sport_info = 6
            if($wire !== 2) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
            }
            $len = Protobuf::read_varint($fp, $limit);
            if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
            $limit -= $len;
            $this->sportInfo[] = new \data\PbSportInfo($fp, $len);
            if ($len !== 0) throw new \Exception('new \data\PbSportInfo did not read the full length');

            break;
          case 7: // repeated .data.PbActivityInfo activity_info = 7
            if($wire !== 2) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
            }
            $len = Protobuf::read_varint($fp, $limit);
            if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
            $limit -= $len;
            $this->activityInfo[] = new \data\PbActivityInfo($fp, $len);
            if ($len !== 0) throw new \Exception('new \data\PbActivityInfo did not read the full length');

            break;
          case 8: // repeated .data.PbInActivityTriggerInfo inactivity_trigger = 8
            if($wire !== 2) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
            }
            $len = Protobuf::read_varint($fp, $limit);
            if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
            $limit -= $len;
            $this->inactivityTrigger[] = new \data\PbInActivityTriggerInfo($fp, $len);
            if ($len !== 0) throw new \Exception('new \data\PbInActivityTriggerInfo did not read the full length');

            break;
          case 9: // repeated .data.PbInActivityNonWearTriggerInfo inactivity_non_wear_trigger = 9
            if($wire !== 2) {
              throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
            }
            $len = Protobuf::read_varint($fp, $limit);
            if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
            $limit -= $len;
            $this->inactivityNonWearTrigger[] = new \data\PbInActivityNonWearTriggerInfo($fp, $len);
            if ($len !== 0) throw new \Exception('new \data\PbInActivityNonWearTriggerInfo did not read the full length');

            break;
          default:
            $limit -= Protobuf::skip_field($fp, $wire);
        }
      }
      if (!$this->validate()) throw new \Exception('Required fields are missing');
    }

    public function write($fp) {
      if (!$this->validate())
        throw new \Exception('Required fields are missing');
      if (!is_null($this->startTime)) {
        fwrite($fp, "\x0a", 1);
        Protobuf::write_varint($fp, $this->startTime->size());
        $this->startTime->write($fp);
      }
      if (!is_null($this->metRecordingInterval)) {
        fwrite($fp, "\x12", 1);
        Protobuf::write_varint($fp, $this->metRecordingInterval->size());
        $this->metRecordingInterval->write($fp);
      }
      if (!is_null($this->stepsRecordingInterval)) {
        fwrite($fp, "\x1a", 1);
        Protobuf::write_varint($fp, $this->stepsRecordingInterval->size());
        $this->stepsRecordingInterval->write($fp);
      }
      foreach($this->metSamples as $v) {
        fwrite($fp, "%", 1);
        Protobuf::write_float($fp, $v);
      }
      foreach($this->stepsSamples as $v) {
        fwrite($fp, "(", 1);
        Protobuf::write_varint($fp, $v);
      }
      foreach($this->sportInfo as $v) {
        fwrite($fp, "2", 1);
        Protobuf::write_varint($fp, $v->size());
        $v->write($fp);
      }
      foreach($this->activityInfo as $v) {
        fwrite($fp, ":", 1);
        Protobuf::write_varint($fp, $v->size());
        $v->write($fp);
      }
      foreach($this->inactivityTrigger as $v) {
        fwrite($fp, "B", 1);
        Protobuf::write_varint($fp, $v->size());
        $v->write($fp);
      }
      foreach($this->inactivityNonWearTrigger as $v) {
        fwrite($fp, "J", 1);
        Protobuf::write_varint($fp, $v->size());
        $v->write($fp);
      }
    }

    public function size() {
      $size = 0;
      if (!is_null($this->startTime)) {
        $l = $this->startTime->size();
        $size += 1 + Protobuf::size_varint($l) + $l;
      }
      if (!is_null($this->metRecordingInterval)) {
        $l = $this->metRecordingInterval->size();
        $size += 1 + Protobuf::size_varint($l) + $l;
      }
      if (!is_null($this->stepsRecordingInterval)) {
        $l = $this->stepsRecordingInterval->size();
        $size += 1 + Protobuf::size_varint($l) + $l;
      }
      foreach($this->metSamples as $v) {
        $size += 5;
      }
      foreach($this->stepsSamples as $v) {
        $size += 1 + Protobuf::size_varint($v);
      }
      foreach($this->sportInfo as $v) {
        $l = $v->size();
        $size += 1 + Protobuf::size_varint($l) + $l;
      }
      foreach($this->activityInfo as $v) {
        $l = $v->size();
        $size += 1 + Protobuf::size_varint($l) + $l;
      }
      foreach($this->inactivityTrigger as $v) {
        $l = $v->size();
        $size += 1 + Protobuf::size_varint($l) + $l;
      }
      foreach($this->inactivityNonWearTrigger as $v) {
        $l = $v->size();
        $size += 1 + Protobuf::size_varint($l) + $l;
      }
      return $size;
    }

    public function validate() {
      if ($this->startTime === null) return false;
      if ($this->metRecordingInterval === null) return false;
      if ($this->stepsRecordingInterval === null) return false;
      return true;
    }

    public function clearStartTime() { $this->startTime = null; }
    public function hasStartTime() { return $this->startTime !== null; }
    public function getStartTime() { if($this->startTime !== null) return $this->startTime; else return null;}
    public function setStartTime(PbLocalDateTime $value) { $this->startTime = $value; }

    public function clearMetRecordingInterval() { $this->metRecordingInterval = null; }
    public function hasMetRecordingInterval() { return $this->metRecordingInterval !== null; }
    public function getMetRecordingInterval() { if($this->metRecordingInterval !== null) return $this->metRecordingInterval; else return null;}
    public function setMetRecordingInterval(PbDuration $value) { $this->metRecordingInterval = $value; }

    public function clearStepsRecordingInterval() { $this->stepsRecordingInterval = null; }
    public function hasStepsRecordingInterval() { return $this->stepsRecordingInterval !== null; }
    public function getStepsRecordingInterval() { if($this->stepsRecordingInterval !== null) return $this->stepsRecordingInterval; else return null;}
    public function setStepsRecordingInterval(PbDuration $value) { $this->stepsRecordingInterval = $value; }

    public function clearMetSamples() { $this->metSamples = array(); }
    public function getMetSamplesCount() { return count($this->metSamples); }
    public function getMetSamples($index) { return $this->metSamples[$index]; }
    public function getMetSamplesArray() { return $this->metSamples; }
    public function setMetSamples($index, array $value) {$this->metSamples[$index] = $value; }
    public function addMetSamples(array $value) { $this->metSamples[] = $value; }
    public function addAllMetSamples(array $values) { foreach($values as $value) {$this->metSamples[] = $value; }}

    public function clearStepsSamples() { $this->stepsSamples = array(); }
    public function getStepsSamplesCount() { return count($this->stepsSamples); }
    public function getStepsSamples($index) { return $this->stepsSamples[$index]; }
    public function getStepsSamplesArray() { return $this->stepsSamples; }
    public function setStepsSamples($index, array $value) {$this->stepsSamples[$index] = $value; }
    public function addStepsSamples(array $value) { $this->stepsSamples[] = $value; }
    public function addAllStepsSamples(array $values) { foreach($values as $value) {$this->stepsSamples[] = $value; }}

    public function clearSportInfo() { $this->sportInfo = array(); }
    public function getSportInfoCount() { return count($this->sportInfo); }
    public function getSportInfo($index) { return $this->sportInfo[$index]; }
    public function getSportInfoArray() { return $this->sportInfo; }
    public function setSportInfo($index, array $value) {$this->sportInfo[$index] = $value; }
    public function addSportInfo(array $value) { $this->sportInfo[] = $value; }
    public function addAllSportInfo(array $values) { foreach($values as $value) {$this->sportInfo[] = $value; }}

    public function clearActivityInfo() { $this->activityInfo = array(); }
    public function getActivityInfoCount() { return count($this->activityInfo); }
    public function getActivityInfo($index) { return $this->activityInfo[$index]; }
    public function getActivityInfoArray() { return $this->activityInfo; }
    public function setActivityInfo($index, array $value) {$this->activityInfo[$index] = $value; }
    public function addActivityInfo(array $value) { $this->activityInfo[] = $value; }
    public function addAllActivityInfo(array $values) { foreach($values as $value) {$this->activityInfo[] = $value; }}

    public function clearInactivityTrigger() { $this->inactivityTrigger = array(); }
    public function getInactivityTriggerCount() { return count($this->inactivityTrigger); }
    public function getInactivityTrigger($index) { return $this->inactivityTrigger[$index]; }
    public function getInactivityTriggerArray() { return $this->inactivityTrigger; }
    public function setInactivityTrigger($index, array $value) {$this->inactivityTrigger[$index] = $value; }
    public function addInactivityTrigger(array $value) { $this->inactivityTrigger[] = $value; }
    public function addAllInactivityTrigger(array $values) { foreach($values as $value) {$this->inactivityTrigger[] = $value; }}

    public function clearInactivityNonWearTrigger() { $this->inactivityNonWearTrigger = array(); }
    public function getInactivityNonWearTriggerCount() { return count($this->inactivityNonWearTrigger); }
    public function getInactivityNonWearTrigger($index) { return $this->inactivityNonWearTrigger[$index]; }
    public function getInactivityNonWearTriggerArray() { return $this->inactivityNonWearTrigger; }
    public function setInactivityNonWearTrigger($index, array $value) {$this->inactivityNonWearTrigger[$index] = $value; }
    public function addInactivityNonWearTrigger(array $value) { $this->inactivityNonWearTrigger[] = $value; }
    public function addAllInactivityNonWearTrigger(array $values) { foreach($values as $value) {$this->inactivityNonWearTrigger[] = $value; }}

    public function __toString() {
      return ''
           . Protobuf::toString('start_time', $this->startTime, null)
           . Protobuf::toString('met_recording_interval', $this->metRecordingInterval, null)
           . Protobuf::toString('steps_recording_interval', $this->stepsRecordingInterval, null)
           . Protobuf::toString('met_samples', $this->metSamples, 0)
           . Protobuf::toString('steps_samples', $this->stepsSamples, 0)
           . Protobuf::toString('sport_info', $this->sportInfo, null)
           . Protobuf::toString('activity_info', $this->activityInfo, null)
           . Protobuf::toString('inactivity_trigger', $this->inactivityTrigger, null)
           . Protobuf::toString('inactivity_non_wear_trigger', $this->inactivityNonWearTrigger, null);
    }

    // @@protoc_insertion_point(class_scope:data.PbActivitySamples)
  }

}