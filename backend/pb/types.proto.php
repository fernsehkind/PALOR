<?php
// Generated by https://github.com/bramp/protoc-gen-php// Please include protocolbuffers before this file, for example:
//   require('protocolbuffers.inc.php');
//   require('types.proto.php');

// enum PbDataType
abstract class PbDataType extends ProtobufEnum {
  const UNDEFINED = 0;
  const INHERITED = 1;
  const ENUM = 2;
  const MILLIS = 3;
  const SECOND = 4;
  const MINUTE = 5;
  const HOUR = 6;
  const HOURS = 7;
  const DAY = 8;
  const MONTH = 9;
  const YEAR = 10;
  const WEIGHT = 11;
  const HEIGHT = 12;
  const VO2MAX = 13;
  const HEARTRATE = 20;
  const HR_PERCENT = 21;
  const HR_RESERVE = 22;
  const SPEED = 23;
  const CADENCE = 24;
  const ALTITUDE = 25;
  const POWER = 26;
  const POWER_LRB = 27;
  const POWER_PI = 28;
  const TEMPERATURE = 29;
  const ACTIVITY = 30;
  const STRIDE_LENGTH = 31;
  const INCLINE = 32;
  const DECLINE = 33;
  const DISTANCE = 52;
  const ENERGY = 53;
  const FAT_PERCENTS = 54;
  const ASCENT = 55;
  const DESCENT = 56;
  const LATITUDE = 57;
  const LONGITUDE = 58;
  const HERTZ = 59;
  const PERCENT = 60;
  const CUMULATED_ACTIVITY_DAY = 61;
  const RUNNING_INDEX = 62;
  const RR_INTERVAL = 63;
  const Z_INDEX = 64;
  const EXERCISE_TARGET_INDEX = 65;
  const TIME_ZONE_OFFSET = 66;
  const WHEEL_SIZE = 67;
  const FITNESS_CLASS = 68;
  const ACCELERATION = 69;
  const CRANK_LENGTH = 70;
  const ANGLE_DEGREE = 71;
  const NEWTON = 72;
  const FUNCTIONAL_THRESHOLD_POWER = 73;
  const CALORIES = 74;
  const SPEED_CALIBRATION_OFFSET = 75;

  public static $_values = array(
    0 => "UNDEFINED",
    1 => "INHERITED",
    2 => "ENUM",
    3 => "MILLIS",
    4 => "SECOND",
    5 => "MINUTE",
    6 => "HOUR",
    7 => "HOURS",
    8 => "DAY",
    9 => "MONTH",
    10 => "YEAR",
    11 => "WEIGHT",
    12 => "HEIGHT",
    13 => "VO2MAX",
    20 => "HEARTRATE",
    21 => "HR_PERCENT",
    22 => "HR_RESERVE",
    23 => "SPEED",
    24 => "CADENCE",
    25 => "ALTITUDE",
    26 => "POWER",
    27 => "POWER_LRB",
    28 => "POWER_PI",
    29 => "TEMPERATURE",
    30 => "ACTIVITY",
    31 => "STRIDE_LENGTH",
    32 => "INCLINE",
    33 => "DECLINE",
    52 => "DISTANCE",
    53 => "ENERGY",
    54 => "FAT_PERCENTS",
    55 => "ASCENT",
    56 => "DESCENT",
    57 => "LATITUDE",
    58 => "LONGITUDE",
    59 => "HERTZ",
    60 => "PERCENT",
    61 => "CUMULATED_ACTIVITY_DAY",
    62 => "RUNNING_INDEX",
    63 => "RR_INTERVAL",
    64 => "Z_INDEX",
    65 => "EXERCISE_TARGET_INDEX",
    66 => "TIME_ZONE_OFFSET",
    67 => "WHEEL_SIZE",
    68 => "FITNESS_CLASS",
    69 => "ACCELERATION",
    70 => "CRANK_LENGTH",
    71 => "ANGLE_DEGREE",
    72 => "NEWTON",
    73 => "FUNCTIONAL_THRESHOLD_POWER",
    74 => "CALORIES",
    75 => "SPEED_CALIBRATION_OFFSET",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbHeartRateView
abstract class PbHeartRateView extends ProtobufEnum {
  const HEART_RATE_VIEW_BPM = 1;
  const HEART_RATE_VIEW_PERCENTS_OF_HR_RESERVE = 2;
  const HEART_RATE_VIEW_PERCENTS_OF_MAX_HR = 3;

  public static $_values = array(
    1 => "HEART_RATE_VIEW_BPM",
    2 => "HEART_RATE_VIEW_PERCENTS_OF_HR_RESERVE",
    3 => "HEART_RATE_VIEW_PERCENTS_OF_MAX_HR",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbUnitSystem
abstract class PbUnitSystem extends ProtobufEnum {
  const METRIC = 1;
  const IMPERIAL = 2;

  public static $_values = array(
    1 => "METRIC",
    2 => "IMPERIAL",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbTimeSelection
abstract class PbTimeSelection extends ProtobufEnum {
  const TIME_1 = 1;
  const TIME_2 = 2;

  public static $_values = array(
    1 => "TIME_1",
    2 => "TIME_2",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbTimeFormat
abstract class PbTimeFormat extends ProtobufEnum {
  const TIME_FORMAT_24H = 1;
  const TIME_FORMAT_12H = 2;

  public static $_values = array(
    1 => "TIME_FORMAT_24H",
    2 => "TIME_FORMAT_12H",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbTimeFormatSeparator
abstract class PbTimeFormatSeparator extends ProtobufEnum {
  const TIME_FORMAT_SEPARATOR_DOT = 1;
  const TIME_FORMAT_SEPARATOR_COLON = 2;

  public static $_values = array(
    1 => "TIME_FORMAT_SEPARATOR_DOT",
    2 => "TIME_FORMAT_SEPARATOR_COLON",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbStartDayOfWeek
abstract class PbStartDayOfWeek extends ProtobufEnum {
  const MONDAY = 1;
  const SATURDAY = 2;
  const SUNDAY = 3;

  public static $_values = array(
    1 => "MONDAY",
    2 => "SATURDAY",
    3 => "SUNDAY",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbDateFormatSeparator
abstract class PbDateFormatSeparator extends ProtobufEnum {
  const DOT = 1;
  const SLASH = 2;
  const HYPHEN = 3;

  public static $_values = array(
    1 => "DOT",
    2 => "SLASH",
    3 => "HYPHEN",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbDateFormat
abstract class PbDateFormat extends ProtobufEnum {
  const DD_MM_YYYY = 1;
  const MM_DD_YYYY = 2;
  const YYYY_MM_DD = 3;

  public static $_values = array(
    1 => "DD_MM_YYYY",
    2 => "MM_DD_YYYY",
    3 => "YYYY_MM_DD",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbFeatureType
abstract class PbFeatureType extends ProtobufEnum {
  const FEATURE_TYPE_HEART_RATE = 1;
  const FEATURE_TYPE_RR_INTERVAL = 2;
  const FEATURE_TYPE_SPEED = 3;
  const FEATURE_TYPE_DISTANCE = 4;
  const FEATURE_TYPE_BIKE_CADENCE = 5;
  const FEATURE_TYPE_BIKE_POWER = 6;
  const FEATURE_TYPE_GPS_LOCATION = 7;
  const FEATURE_TYPE_RUNNING_CADENCE = 8;
  const FEATURE_TYPE_PRESS_TEMPERATURE = 9;
  const FEATURE_TYPE_ALTITUDE = 10;
  const FEATURE_TYPE_STEPS = 11;
  const FEATURE_TYPE_ACTIVITY = 12;
  const FEATURE_TYPE_STRIDE_LENGTH = 13;
  const FEATURE_TYPE_RSC_MOVING_TYPE = 14;
  const FEATURE_TYPE_JUMP_HEIGTH = 15;
  const FEATURE_TYPE_COMPASS_HEADING = 16;
  const FEATURE_TYPE_GPS_SPEED = 17;
  const FEATURE_TYPE_GPS_DISTANCE = 18;
  const FEATURE_TYPE_GPS_ALTITUDE = 19;
  const FEATURE_TYPE_BIKE_WHEEL_REVOLUTION = 20;
  const FEATURE_TYPE_BIKE_CRANK_REVOLUTION = 21;
  const FEATURE_TYPE_AS_SPEED = 22;
  const FEATURE_TYPE_AS_CADENCE = 23;
  const FEATURE_TYPE_AS_DISTANCE = 24;
  const FEATURE_TYPE_AS_SWR_STATE = 25;
  const FEATURE_TYPE_BATTERY_LEVEL = 26;
  const FEATURE_TYPE_FILE_TRANSFER = 27;
  const FEATURE_TYPE_PUSH_NOTIFICATIONS = 28;
  const FEATURE_TYPE_WEIGHT_SCALE = 29;

  public static $_values = array(
    1 => "FEATURE_TYPE_HEART_RATE",
    2 => "FEATURE_TYPE_RR_INTERVAL",
    3 => "FEATURE_TYPE_SPEED",
    4 => "FEATURE_TYPE_DISTANCE",
    5 => "FEATURE_TYPE_BIKE_CADENCE",
    6 => "FEATURE_TYPE_BIKE_POWER",
    7 => "FEATURE_TYPE_GPS_LOCATION",
    8 => "FEATURE_TYPE_RUNNING_CADENCE",
    9 => "FEATURE_TYPE_PRESS_TEMPERATURE",
    10 => "FEATURE_TYPE_ALTITUDE",
    11 => "FEATURE_TYPE_STEPS",
    12 => "FEATURE_TYPE_ACTIVITY",
    13 => "FEATURE_TYPE_STRIDE_LENGTH",
    14 => "FEATURE_TYPE_RSC_MOVING_TYPE",
    15 => "FEATURE_TYPE_JUMP_HEIGTH",
    16 => "FEATURE_TYPE_COMPASS_HEADING",
    17 => "FEATURE_TYPE_GPS_SPEED",
    18 => "FEATURE_TYPE_GPS_DISTANCE",
    19 => "FEATURE_TYPE_GPS_ALTITUDE",
    20 => "FEATURE_TYPE_BIKE_WHEEL_REVOLUTION",
    21 => "FEATURE_TYPE_BIKE_CRANK_REVOLUTION",
    22 => "FEATURE_TYPE_AS_SPEED",
    23 => "FEATURE_TYPE_AS_CADENCE",
    24 => "FEATURE_TYPE_AS_DISTANCE",
    25 => "FEATURE_TYPE_AS_SWR_STATE",
    26 => "FEATURE_TYPE_BATTERY_LEVEL",
    27 => "FEATURE_TYPE_FILE_TRANSFER",
    28 => "FEATURE_TYPE_PUSH_NOTIFICATIONS",
    29 => "FEATURE_TYPE_WEIGHT_SCALE",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbMovingType
abstract class PbMovingType extends ProtobufEnum {
  const WALKING = 0;
  const RUNNING = 1;
  const STANDING = 2;

  public static $_values = array(
    0 => "WALKING",
    1 => "RUNNING",
    2 => "STANDING",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbOperationType
abstract class PbOperationType extends ProtobufEnum {
  const MULTIPLY = 1;
  const SUM = 2;

  public static $_values = array(
    1 => "MULTIPLY",
    2 => "SUM",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbExerciseFeedback
abstract class PbExerciseFeedback extends ProtobufEnum {
  const FEEDBACK_NONE = 1;
  const FEEDBACK_1 = 2;
  const FEEDBACK_2 = 3;
  const FEEDBACK_3 = 4;
  const FEEDBACK_4 = 5;
  const FEEDBACK_5 = 6;
  const FEEDBACK_6 = 7;
  const FEEDBACK_7 = 8;
  const FEEDBACK_8 = 9;
  const FEEDBACK_9 = 10;
  const FEEDBACK_10 = 11;
  const FEEDBACK_11 = 12;
  const FEEDBACK_12 = 13;
  const FEEDBACK_13 = 14;
  const FEEDBACK_14 = 15;
  const FEEDBACK_15 = 16;
  const FEEDBACK_16 = 17;
  const FEEDBACK_17 = 18;

  public static $_values = array(
    1 => "FEEDBACK_NONE",
    2 => "FEEDBACK_1",
    3 => "FEEDBACK_2",
    4 => "FEEDBACK_3",
    5 => "FEEDBACK_4",
    6 => "FEEDBACK_5",
    7 => "FEEDBACK_6",
    8 => "FEEDBACK_7",
    9 => "FEEDBACK_8",
    10 => "FEEDBACK_9",
    11 => "FEEDBACK_10",
    12 => "FEEDBACK_11",
    13 => "FEEDBACK_12",
    14 => "FEEDBACK_13",
    15 => "FEEDBACK_14",
    16 => "FEEDBACK_15",
    17 => "FEEDBACK_16",
    18 => "FEEDBACK_17",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbHeartRateZoneSettingSource
abstract class PbHeartRateZoneSettingSource extends ProtobufEnum {
  const HEART_RATE_ZONE_SETTING_SOURCE_DEFAULT = 0;
  const HEART_RATE_ZONE_SETTING_SOURCE_THRESHOLD = 1;
  const HEART_RATE_ZONE_SETTING_SOURCE_FREE = 2;

  public static $_values = array(
    0 => "HEART_RATE_ZONE_SETTING_SOURCE_DEFAULT",
    1 => "HEART_RATE_ZONE_SETTING_SOURCE_THRESHOLD",
    2 => "HEART_RATE_ZONE_SETTING_SOURCE_FREE",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbPowerZoneSettingSource
abstract class PbPowerZoneSettingSource extends ProtobufEnum {
  const POWER_ZONE_SETTING_SOURCE_DEFAULT = 0;
  const POWER_ZONE_SETTING_SOURCE_FREE = 1;

  public static $_values = array(
    0 => "POWER_ZONE_SETTING_SOURCE_DEFAULT",
    1 => "POWER_ZONE_SETTING_SOURCE_FREE",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbSpeedZoneSettingSource
abstract class PbSpeedZoneSettingSource extends ProtobufEnum {
  const SPEED_ZONE_SETTING_SOURCE_DEFAULT = 0;
  const SPEED_ZONE_SETTING_SOURCE_FREE = 1;

  public static $_values = array(
    0 => "SPEED_ZONE_SETTING_SOURCE_DEFAULT",
    1 => "SPEED_ZONE_SETTING_SOURCE_FREE",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbMacType
abstract class PbMacType extends ProtobufEnum {
  const MAC_TYPE_PUBLIC = 0;
  const MAC_TYPE_STATIC = 1;
  const MAC_TYPE_PRIVATE_NONRESOLVABLE = 2;
  const MAC_TYPE_PRIVATE_RESOLVABLE = 3;
  const MAC_TYPE_BT_CLASSIC = 4;

  public static $_values = array(
    0 => "MAC_TYPE_PUBLIC",
    1 => "MAC_TYPE_STATIC",
    2 => "MAC_TYPE_PRIVATE_NONRESOLVABLE",
    3 => "MAC_TYPE_PRIVATE_RESOLVABLE",
    4 => "MAC_TYPE_BT_CLASSIC",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbSwimmingStyle
abstract class PbSwimmingStyle extends ProtobufEnum {
  const OTHER = -1;
  const TURN = 0;
  const OTHER_SWIMMING = 10;
  const FREESTYLE = 11;
  const BREASTSTROKE = 12;
  const BACKSTROKE = 13;
  const BUTTERFLY = 14;

  public static $_values = array(
    -1 => "OTHER",
    0 => "TURN",
    10 => "OTHER_SWIMMING",
    11 => "FREESTYLE",
    12 => "BREASTSTROKE",
    13 => "BACKSTROKE",
    14 => "BUTTERFLY",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbSwimmingPoolUnits
abstract class PbSwimmingPoolUnits extends ProtobufEnum {
  const SWIMMING_POOL_METERS = 0;
  const SWIMMING_POOL_YARDS = 1;

  public static $_values = array(
    0 => "SWIMMING_POOL_METERS",
    1 => "SWIMMING_POOL_YARDS",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbExerciseTargetType
abstract class PbExerciseTargetType extends ProtobufEnum {
  const EXERCISE_TARGET_TYPE_FREE = 0;
  const EXERCISE_TARGET_TYPE_VOLUME = 1;
  const EXERCISE_TARGET_TYPE_PHASED = 2;
  const EXERCISE_TARGET_TYPE_ROUTE = 3;
  const EXERCISE_TARGET_TYPE_STEADY_RACE_PACE = 4;
  const EXERCISE_TARGET_TYPE_ROUTE_RACE_PACE = 5;

  public static $_values = array(
    0 => "EXERCISE_TARGET_TYPE_FREE",
    1 => "EXERCISE_TARGET_TYPE_VOLUME",
    2 => "EXERCISE_TARGET_TYPE_PHASED",
    3 => "EXERCISE_TARGET_TYPE_ROUTE",
    4 => "EXERCISE_TARGET_TYPE_STEADY_RACE_PACE",
    5 => "EXERCISE_TARGET_TYPE_ROUTE_RACE_PACE",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// message PbRangeOptions
final class PbRangeOptions extends ProtobufMessage {

  private $_unknown;
  private $minValue = null; // optional int32 min_value = 1
  private $maxValue = null; // optional int32 max_value = 2

  public function __construct($in = null, &$limit = PHP_INT_MAX) {
    parent::__construct($in, $limit);
  }

  public function read($fp, &$limit = PHP_INT_MAX) {
    $fp = ProtobufIO::toStream($fp, $limit);
    while(!feof($fp) && $limit > 0) {
      $tag = Protobuf::read_varint($fp, $limit);
      if ($tag === false) break;
      $wire  = $tag & 0x07;
      $field = $tag >> 3;
      switch($field) {
        case 1: // optional int32 min_value = 1
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_signed_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_INT32 || $tmp > Protobuf::MAX_INT32) throw new \Exception('int32 out of range');$this->minValue = $tmp;

          break;
        case 2: // optional int32 max_value = 2
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_signed_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_INT32 || $tmp > Protobuf::MAX_INT32) throw new \Exception('int32 out of range');$this->maxValue = $tmp;

          break;
        default:
          $limit -= Protobuf::skip_field($fp, $wire);
      }
    }
    if (!$this->validate()) throw new \Exception('Required fields are missing');
  }

  public function write($fp) {
    if (!$this->validate())
      throw new \Exception('Required fields are missing');
    if (!is_null($this->minValue)) {
      fwrite($fp, "\x08", 1);
      Protobuf::write_varint($fp, $this->minValue);
    }
    if (!is_null($this->maxValue)) {
      fwrite($fp, "\x10", 1);
      Protobuf::write_varint($fp, $this->maxValue);
    }
  }

  public function size() {
    $size = 0;
    if (!is_null($this->minValue)) {
      $size += 1 + Protobuf::size_varint($this->minValue);
    }
    if (!is_null($this->maxValue)) {
      $size += 1 + Protobuf::size_varint($this->maxValue);
    }
    return $size;
  }

  public function validate() {
    return true;
  }

  public function clearMinValue() { $this->minValue = null; }
  public function hasMinValue() { return $this->minValue !== null; }
  public function getMinValue() { if($this->minValue !== null) return $this->minValue; else return 0;}
  public function setMinValue($value) { $this->minValue = $value; }

  public function clearMaxValue() { $this->maxValue = null; }
  public function hasMaxValue() { return $this->maxValue !== null; }
  public function getMaxValue() { if($this->maxValue !== null) return $this->maxValue; else return 0;}
  public function setMaxValue($value) { $this->maxValue = $value; }

  public function __toString() {
    return ''
         . Protobuf::toString('min_value', $this->minValue, 0)
         . Protobuf::toString('max_value', $this->maxValue, 0);
  }

  // @@protoc_insertion_point(class_scope:PbRangeOptions)
}

// message PbDate
final class PbDate extends ProtobufMessage {

  private $_unknown;
  private $year = null; // required uint32 year = 1
  private $month = null; // required uint32 month = 2
  private $day = null; // required uint32 day = 3

  public function __construct($in = null, &$limit = PHP_INT_MAX) {
    parent::__construct($in, $limit);
  }

  public function read($fp, &$limit = PHP_INT_MAX) {
    $fp = ProtobufIO::toStream($fp, $limit);
    while(!feof($fp) && $limit > 0) {
      $tag = Protobuf::read_varint($fp, $limit);
      if ($tag === false) break;
      $wire  = $tag & 0x07;
      $field = $tag >> 3;
      switch($field) {
        case 1: // required uint32 year = 1
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->year = $tmp;

          break;
        case 2: // required uint32 month = 2
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->month = $tmp;

          break;
        case 3: // required uint32 day = 3
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->day = $tmp;

          break;
        default:
          $limit -= Protobuf::skip_field($fp, $wire);
      }
    }
    if (!$this->validate()) throw new \Exception('Required fields are missing');
  }

  public function write($fp) {
    if (!$this->validate())
      throw new \Exception('Required fields are missing');
    if (!is_null($this->year)) {
      fwrite($fp, "\x08", 1);
      Protobuf::write_varint($fp, $this->year);
    }
    if (!is_null($this->month)) {
      fwrite($fp, "\x10", 1);
      Protobuf::write_varint($fp, $this->month);
    }
    if (!is_null($this->day)) {
      fwrite($fp, "\x18", 1);
      Protobuf::write_varint($fp, $this->day);
    }
  }

  public function size() {
    $size = 0;
    if (!is_null($this->year)) {
      $size += 1 + Protobuf::size_varint($this->year);
    }
    if (!is_null($this->month)) {
      $size += 1 + Protobuf::size_varint($this->month);
    }
    if (!is_null($this->day)) {
      $size += 1 + Protobuf::size_varint($this->day);
    }
    return $size;
  }

  public function validate() {
    if ($this->year === null) return false;
    if ($this->month === null) return false;
    if ($this->day === null) return false;
    return true;
  }

  public function clearYear() { $this->year = null; }
  public function hasYear() { return $this->year !== null; }
  public function getYear() { if($this->year !== null) return $this->year; else return 0;}
  public function setYear($value) { $this->year = $value; }

  public function clearMonth() { $this->month = null; }
  public function hasMonth() { return $this->month !== null; }
  public function getMonth() { if($this->month !== null) return $this->month; else return 0;}
  public function setMonth($value) { $this->month = $value; }

  public function clearDay() { $this->day = null; }
  public function hasDay() { return $this->day !== null; }
  public function getDay() { if($this->day !== null) return $this->day; else return 0;}
  public function setDay($value) { $this->day = $value; }

  public function __toString() {
    return ''
         . Protobuf::toString('year', $this->year, 0)
         . Protobuf::toString('month', $this->month, 0)
         . Protobuf::toString('day', $this->day, 0);
  }

  // @@protoc_insertion_point(class_scope:PbDate)
}

// message PbTime
final class PbTime extends ProtobufMessage {

  private $_unknown;
  private $hour = null; // required uint32 hour = 1
  private $minute = null; // required uint32 minute = 2
  private $seconds = null; // required uint32 seconds = 3
  private $millis = null; // optional uint32 millis = 4 [default = 0]

  public function __construct($in = null, &$limit = PHP_INT_MAX) {
    parent::__construct($in, $limit);
  }

  public function read($fp, &$limit = PHP_INT_MAX) {
    $fp = ProtobufIO::toStream($fp, $limit);
    while(!feof($fp) && $limit > 0) {
      $tag = Protobuf::read_varint($fp, $limit);
      if ($tag === false) break;
      $wire  = $tag & 0x07;
      $field = $tag >> 3;
      switch($field) {
        case 1: // required uint32 hour = 1
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->hour = $tmp;

          break;
        case 2: // required uint32 minute = 2
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->minute = $tmp;

          break;
        case 3: // required uint32 seconds = 3
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->seconds = $tmp;

          break;
        case 4: // optional uint32 millis = 4 [default = 0]
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->millis = $tmp;

          break;
        default:
          $limit -= Protobuf::skip_field($fp, $wire);
      }
    }
    if (!$this->validate()) throw new \Exception('Required fields are missing');
  }

  public function write($fp) {
    if (!$this->validate())
      throw new \Exception('Required fields are missing');
    if (!is_null($this->hour)) {
      fwrite($fp, "\x08", 1);
      Protobuf::write_varint($fp, $this->hour);
    }
    if (!is_null($this->minute)) {
      fwrite($fp, "\x10", 1);
      Protobuf::write_varint($fp, $this->minute);
    }
    if (!is_null($this->seconds)) {
      fwrite($fp, "\x18", 1);
      Protobuf::write_varint($fp, $this->seconds);
    }
    if (!is_null($this->millis)) {
      fwrite($fp, " ", 1);
      Protobuf::write_varint($fp, $this->millis);
    }
  }

  public function size() {
    $size = 0;
    if (!is_null($this->hour)) {
      $size += 1 + Protobuf::size_varint($this->hour);
    }
    if (!is_null($this->minute)) {
      $size += 1 + Protobuf::size_varint($this->minute);
    }
    if (!is_null($this->seconds)) {
      $size += 1 + Protobuf::size_varint($this->seconds);
    }
    if (!is_null($this->millis)) {
      $size += 1 + Protobuf::size_varint($this->millis);
    }
    return $size;
  }

  public function validate() {
    if ($this->hour === null) return false;
    if ($this->minute === null) return false;
    if ($this->seconds === null) return false;
    return true;
  }

  public function clearHour() { $this->hour = null; }
  public function hasHour() { return $this->hour !== null; }
  public function getHour() { if($this->hour !== null) return $this->hour; else return 0;}
  public function setHour($value) { $this->hour = $value; }

  public function clearMinute() { $this->minute = null; }
  public function hasMinute() { return $this->minute !== null; }
  public function getMinute() { if($this->minute !== null) return $this->minute; else return 0;}
  public function setMinute($value) { $this->minute = $value; }

  public function clearSeconds() { $this->seconds = null; }
  public function hasSeconds() { return $this->seconds !== null; }
  public function getSeconds() { if($this->seconds !== null) return $this->seconds; else return 0;}
  public function setSeconds($value) { $this->seconds = $value; }

  public function clearMillis() { $this->millis = null; }
  public function hasMillis() { return $this->millis !== null; }
  public function getMillis() { if($this->millis !== null) return $this->millis; else return 0;}
  public function setMillis($value) { $this->millis = $value; }

  public function __toString() {
    return ''
         . Protobuf::toString('hour', $this->hour, 0)
         . Protobuf::toString('minute', $this->minute, 0)
         . Protobuf::toString('seconds', $this->seconds, 0)
         . Protobuf::toString('millis', $this->millis, 0);
  }

  // @@protoc_insertion_point(class_scope:PbTime)
}

// message PbSystemDateTime
final class PbSystemDateTime extends ProtobufMessage {

  private $_unknown;
  private $date = null; // required .PbDate date = 1
  private $time = null; // required .PbTime time = 2
  private $trusted = null; // required bool trusted = 3

  public function __construct($in = null, &$limit = PHP_INT_MAX) {
    parent::__construct($in, $limit);
  }

  public function read($fp, &$limit = PHP_INT_MAX) {
    $fp = ProtobufIO::toStream($fp, $limit);
    while(!feof($fp) && $limit > 0) {
      $tag = Protobuf::read_varint($fp, $limit);
      if ($tag === false) break;
      $wire  = $tag & 0x07;
      $field = $tag >> 3;
      switch($field) {
        case 1: // required .PbDate date = 1
          if($wire !== 2) {
            throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
          }
          $len = Protobuf::read_varint($fp, $limit);
          if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
          $limit -= $len;
          $this->date = new PbDate($fp, $len);
          if ($len !== 0) throw new \Exception('new PbDate did not read the full length');

          break;
        case 2: // required .PbTime time = 2
          if($wire !== 2) {
            throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
          }
          $len = Protobuf::read_varint($fp, $limit);
          if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
          $limit -= $len;
          $this->time = new PbTime($fp, $len);
          if ($len !== 0) throw new \Exception('new PbTime did not read the full length');

          break;
        case 3: // required bool trusted = 3
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          $this->trusted = ($tmp > 0) ? true : false;

          break;
        default:
          $limit -= Protobuf::skip_field($fp, $wire);
      }
    }
    if (!$this->validate()) throw new \Exception('Required fields are missing');
  }

  public function write($fp) {
    if (!$this->validate())
      throw new \Exception('Required fields are missing');
    if (!is_null($this->date)) {
      fwrite($fp, "\x0a", 1);
      Protobuf::write_varint($fp, $this->date->size());
      $this->date->write($fp);
    }
    if (!is_null($this->time)) {
      fwrite($fp, "\x12", 1);
      Protobuf::write_varint($fp, $this->time->size());
      $this->time->write($fp);
    }
    if (!is_null($this->trusted)) {
      fwrite($fp, "\x18", 1);
      Protobuf::write_varint($fp, $this->trusted ? 1 : 0);
    }
  }

  public function size() {
    $size = 0;
    if (!is_null($this->date)) {
      $l = $this->date->size();
      $size += 1 + Protobuf::size_varint($l) + $l;
    }
    if (!is_null($this->time)) {
      $l = $this->time->size();
      $size += 1 + Protobuf::size_varint($l) + $l;
    }
    if (!is_null($this->trusted)) {
      $size += 2;
    }
    return $size;
  }

  public function validate() {
    if ($this->date === null) return false;
    if ($this->time === null) return false;
    if ($this->trusted === null) return false;
    return true;
  }

  public function clearDate() { $this->date = null; }
  public function hasDate() { return $this->date !== null; }
  public function getDate() { if($this->date !== null) return $this->date; else return null;}
  public function setDate(PbDate $value) { $this->date = $value; }

  public function clearTime() { $this->time = null; }
  public function hasTime() { return $this->time !== null; }
  public function getTime() { if($this->time !== null) return $this->time; else return null;}
  public function setTime(PbTime $value) { $this->time = $value; }

  public function clearTrusted() { $this->trusted = null; }
  public function hasTrusted() { return $this->trusted !== null; }
  public function getTrusted() { if($this->trusted !== null) return $this->trusted; else return false;}
  public function setTrusted($value) { $this->trusted = $value; }

  public function __toString() {
    return ''
         . Protobuf::toString('date', $this->date, null)
         . Protobuf::toString('time', $this->time, null)
         . Protobuf::toString('trusted', $this->trusted, false);
  }

  // @@protoc_insertion_point(class_scope:PbSystemDateTime)
}

// message PbLocalDateTime
final class PbLocalDateTime extends ProtobufMessage {

  private $_unknown;
  private $date = null; // required .PbDate date = 1
  private $time = null; // required .PbTime time = 2
  private $oBSOLETETrusted = null; // required bool OBSOLETE_trusted = 3
  private $timeZoneOffset = null; // optional int32 time_zone_offset = 4

  public function __construct($in = null, &$limit = PHP_INT_MAX) {
    parent::__construct($in, $limit);
  }

  public function read($fp, &$limit = PHP_INT_MAX) {
    $fp = ProtobufIO::toStream($fp, $limit);
    while(!feof($fp) && $limit > 0) {
      $tag = Protobuf::read_varint($fp, $limit);
      if ($tag === false) break;
      $wire  = $tag & 0x07;
      $field = $tag >> 3;
      switch($field) {
        case 1: // required .PbDate date = 1
          if($wire !== 2) {
            throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
          }
          $len = Protobuf::read_varint($fp, $limit);
          if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
          $limit -= $len;
          $this->date = new PbDate($fp, $len);
          if ($len !== 0) throw new \Exception('new PbDate did not read the full length');

          break;
        case 2: // required .PbTime time = 2
          if($wire !== 2) {
            throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
          }
          $len = Protobuf::read_varint($fp, $limit);
          if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
          $limit -= $len;
          $this->time = new PbTime($fp, $len);
          if ($len !== 0) throw new \Exception('new PbTime did not read the full length');

          break;
        case 3: // required bool OBSOLETE_trusted = 3
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          $this->oBSOLETETrusted = ($tmp > 0) ? true : false;

          break;
        case 4: // optional int32 time_zone_offset = 4
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_signed_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_INT32 || $tmp > Protobuf::MAX_INT32) throw new \Exception('int32 out of range');$this->timeZoneOffset = $tmp;

          break;
        default:
          $limit -= Protobuf::skip_field($fp, $wire);
      }
    }
    if (!$this->validate()) throw new \Exception('Required fields are missing');
  }

  public function write($fp) {
    if (!$this->validate())
      throw new \Exception('Required fields are missing');
    if (!is_null($this->date)) {
      fwrite($fp, "\x0a", 1);
      Protobuf::write_varint($fp, $this->date->size());
      $this->date->write($fp);
    }
    if (!is_null($this->time)) {
      fwrite($fp, "\x12", 1);
      Protobuf::write_varint($fp, $this->time->size());
      $this->time->write($fp);
    }
    if (!is_null($this->oBSOLETETrusted)) {
      fwrite($fp, "\x18", 1);
      Protobuf::write_varint($fp, $this->oBSOLETETrusted ? 1 : 0);
    }
    if (!is_null($this->timeZoneOffset)) {
      fwrite($fp, " ", 1);
      Protobuf::write_varint($fp, $this->timeZoneOffset);
    }
  }

  public function size() {
    $size = 0;
    if (!is_null($this->date)) {
      $l = $this->date->size();
      $size += 1 + Protobuf::size_varint($l) + $l;
    }
    if (!is_null($this->time)) {
      $l = $this->time->size();
      $size += 1 + Protobuf::size_varint($l) + $l;
    }
    if (!is_null($this->oBSOLETETrusted)) {
      $size += 2;
    }
    if (!is_null($this->timeZoneOffset)) {
      $size += 1 + Protobuf::size_varint($this->timeZoneOffset);
    }
    return $size;
  }

  public function validate() {
    if ($this->date === null) return false;
    if ($this->time === null) return false;
    if ($this->oBSOLETETrusted === null) return false;
    return true;
  }

  public function clearDate() { $this->date = null; }
  public function hasDate() { return $this->date !== null; }
  public function getDate() { if($this->date !== null) return $this->date; else return null;}
  public function setDate(PbDate $value) { $this->date = $value; }

  public function clearTime() { $this->time = null; }
  public function hasTime() { return $this->time !== null; }
  public function getTime() { if($this->time !== null) return $this->time; else return null;}
  public function setTime(PbTime $value) { $this->time = $value; }

  public function clearOBSOLETETrusted() { $this->oBSOLETETrusted = null; }
  public function hasOBSOLETETrusted() { return $this->oBSOLETETrusted !== null; }
  public function getOBSOLETETrusted() { if($this->oBSOLETETrusted !== null) return $this->oBSOLETETrusted; else return false;}
  public function setOBSOLETETrusted($value) { $this->oBSOLETETrusted = $value; }

  public function clearTimeZoneOffset() { $this->timeZoneOffset = null; }
  public function hasTimeZoneOffset() { return $this->timeZoneOffset !== null; }
  public function getTimeZoneOffset() { if($this->timeZoneOffset !== null) return $this->timeZoneOffset; else return 0;}
  public function setTimeZoneOffset($value) { $this->timeZoneOffset = $value; }

  public function __toString() {
    return ''
         . Protobuf::toString('date', $this->date, null)
         . Protobuf::toString('time', $this->time, null)
         . Protobuf::toString('OBSOLETE_trusted', $this->oBSOLETETrusted, false)
         . Protobuf::toString('time_zone_offset', $this->timeZoneOffset, 0);
  }

  // @@protoc_insertion_point(class_scope:PbLocalDateTime)
}

// message PbDuration
final class PbDuration extends ProtobufMessage {

  private $_unknown;
  private $hours = null; // optional uint32 hours = 1 [default = 0]
  private $minutes = null; // optional uint32 minutes = 2 [default = 0]
  private $seconds = null; // optional uint32 seconds = 3 [default = 0]
  private $millis = null; // optional uint32 millis = 4 [default = 0]

  public function __construct($in = null, &$limit = PHP_INT_MAX) {
    parent::__construct($in, $limit);
  }

  public function read($fp, &$limit = PHP_INT_MAX) {
    $fp = ProtobufIO::toStream($fp, $limit);
    while(!feof($fp) && $limit > 0) {
      $tag = Protobuf::read_varint($fp, $limit);
      if ($tag === false) break;
      $wire  = $tag & 0x07;
      $field = $tag >> 3;
      switch($field) {
        case 1: // optional uint32 hours = 1 [default = 0]
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->hours = $tmp;

          break;
        case 2: // optional uint32 minutes = 2 [default = 0]
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->minutes = $tmp;

          break;
        case 3: // optional uint32 seconds = 3 [default = 0]
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->seconds = $tmp;

          break;
        case 4: // optional uint32 millis = 4 [default = 0]
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->millis = $tmp;

          break;
        default:
          $limit -= Protobuf::skip_field($fp, $wire);
      }
    }
    if (!$this->validate()) throw new \Exception('Required fields are missing');
  }

  public function write($fp) {
    if (!$this->validate())
      throw new \Exception('Required fields are missing');
    if (!is_null($this->hours)) {
      fwrite($fp, "\x08", 1);
      Protobuf::write_varint($fp, $this->hours);
    }
    if (!is_null($this->minutes)) {
      fwrite($fp, "\x10", 1);
      Protobuf::write_varint($fp, $this->minutes);
    }
    if (!is_null($this->seconds)) {
      fwrite($fp, "\x18", 1);
      Protobuf::write_varint($fp, $this->seconds);
    }
    if (!is_null($this->millis)) {
      fwrite($fp, " ", 1);
      Protobuf::write_varint($fp, $this->millis);
    }
  }

  public function size() {
    $size = 0;
    if (!is_null($this->hours)) {
      $size += 1 + Protobuf::size_varint($this->hours);
    }
    if (!is_null($this->minutes)) {
      $size += 1 + Protobuf::size_varint($this->minutes);
    }
    if (!is_null($this->seconds)) {
      $size += 1 + Protobuf::size_varint($this->seconds);
    }
    if (!is_null($this->millis)) {
      $size += 1 + Protobuf::size_varint($this->millis);
    }
    return $size;
  }

  public function validate() {
    return true;
  }

  public function clearHours() { $this->hours = null; }
  public function hasHours() { return $this->hours !== null; }
  public function getHours() { if($this->hours !== null) return $this->hours; else return 0;}
  public function setHours($value) { $this->hours = $value; }

  public function clearMinutes() { $this->minutes = null; }
  public function hasMinutes() { return $this->minutes !== null; }
  public function getMinutes() { if($this->minutes !== null) return $this->minutes; else return 0;}
  public function setMinutes($value) { $this->minutes = $value; }

  public function clearSeconds() { $this->seconds = null; }
  public function hasSeconds() { return $this->seconds !== null; }
  public function getSeconds() { if($this->seconds !== null) return $this->seconds; else return 0;}
  public function setSeconds($value) { $this->seconds = $value; }

  public function clearMillis() { $this->millis = null; }
  public function hasMillis() { return $this->millis !== null; }
  public function getMillis() { if($this->millis !== null) return $this->millis; else return 0;}
  public function setMillis($value) { $this->millis = $value; }

  public function __toString() {
    return ''
         . Protobuf::toString('hours', $this->hours, 0)
         . Protobuf::toString('minutes', $this->minutes, 0)
         . Protobuf::toString('seconds', $this->seconds, 0)
         . Protobuf::toString('millis', $this->millis, 0);
  }

  // @@protoc_insertion_point(class_scope:PbDuration)
}

// enum PbLocation.Fix
abstract class PbLocation_Fix extends ProtobufEnum {
  const FIX_NONE = 0;
  const FIX_2D = 1;
  const FIX_3D = 2;

  public static $_values = array(
    0 => "FIX_NONE",
    1 => "FIX_2D",
    2 => "FIX_3D",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// message PbLocation
final class PbLocation extends ProtobufMessage {

  private $_unknown;
  private $latitude = null; // required double latitude = 1
  private $longitude = null; // required double longitude = 2
  private $timestamp = null; // optional .PbSystemDateTime timestamp = 3
  private $fix = null; // optional .PbLocation.Fix fix = 4 [default = FIX_NONE]
  private $satellites = null; // optional uint32 satellites = 5 [default = 0]

  public function __construct($in = null, &$limit = PHP_INT_MAX) {
    parent::__construct($in, $limit);
  }

  public function read($fp, &$limit = PHP_INT_MAX) {
    $fp = ProtobufIO::toStream($fp, $limit);
    while(!feof($fp) && $limit > 0) {
      $tag = Protobuf::read_varint($fp, $limit);
      if ($tag === false) break;
      $wire  = $tag & 0x07;
      $field = $tag >> 3;
      switch($field) {
        case 1: // required double latitude = 1
          if($wire !== 1) {
            throw new \Exception("Incorrect wire format for field $field, expected: 1 got: $wire");
          }
          $tmp = Protobuf::read_double($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_double returned false');
          $this->latitude = $tmp;

          break;
        case 2: // required double longitude = 2
          if($wire !== 1) {
            throw new \Exception("Incorrect wire format for field $field, expected: 1 got: $wire");
          }
          $tmp = Protobuf::read_double($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_double returned false');
          $this->longitude = $tmp;

          break;
        case 3: // optional .PbSystemDateTime timestamp = 3
          if($wire !== 2) {
            throw new \Exception("Incorrect wire format for field $field, expected: 2 got: $wire");
          }
          $len = Protobuf::read_varint($fp, $limit);
          if ($len === false) throw new \Exception('Protobuf::read_varint returned false');
          $limit -= $len;
          $this->timestamp = new PbSystemDateTime($fp, $len);
          if ($len !== 0) throw new \Exception('new PbSystemDateTime did not read the full length');

          break;
        case 4: // optional .PbLocation.Fix fix = 4 [default = FIX_NONE]
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          $this->fix = $tmp;

          break;
        case 5: // optional uint32 satellites = 5 [default = 0]
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->satellites = $tmp;

          break;
        default:
          $limit -= Protobuf::skip_field($fp, $wire);
      }
    }
    if (!$this->validate()) throw new \Exception('Required fields are missing');
  }

  public function write($fp) {
    if (!$this->validate())
      throw new \Exception('Required fields are missing');
    if (!is_null($this->latitude)) {
      fwrite($fp, "\x09", 1);
      Protobuf::write_double($fp, $this->latitude);
    }
    if (!is_null($this->longitude)) {
      fwrite($fp, "\x11", 1);
      Protobuf::write_double($fp, $this->longitude);
    }
    if (!is_null($this->timestamp)) {
      fwrite($fp, "\x1a", 1);
      Protobuf::write_varint($fp, $this->timestamp->size());
      $this->timestamp->write($fp);
    }
    if (!is_null($this->fix)) {
      fwrite($fp, " ", 1);
      Protobuf::write_varint($fp, $this->fix);
    }
    if (!is_null($this->satellites)) {
      fwrite($fp, "(", 1);
      Protobuf::write_varint($fp, $this->satellites);
    }
  }

  public function size() {
    $size = 0;
    if (!is_null($this->latitude)) {
      $size += 9;
    }
    if (!is_null($this->longitude)) {
      $size += 9;
    }
    if (!is_null($this->timestamp)) {
      $l = $this->timestamp->size();
      $size += 1 + Protobuf::size_varint($l) + $l;
    }
    if (!is_null($this->fix)) {
      $size += 1 + Protobuf::size_varint($this->fix);
    }
    if (!is_null($this->satellites)) {
      $size += 1 + Protobuf::size_varint($this->satellites);
    }
    return $size;
  }

  public function validate() {
    if ($this->latitude === null) return false;
    if ($this->longitude === null) return false;
    return true;
  }

  public function clearLatitude() { $this->latitude = null; }
  public function hasLatitude() { return $this->latitude !== null; }
  public function getLatitude() { if($this->latitude !== null) return $this->latitude; else return 0;}
  public function setLatitude($value) { $this->latitude = $value; }

  public function clearLongitude() { $this->longitude = null; }
  public function hasLongitude() { return $this->longitude !== null; }
  public function getLongitude() { if($this->longitude !== null) return $this->longitude; else return 0;}
  public function setLongitude($value) { $this->longitude = $value; }

  public function clearTimestamp() { $this->timestamp = null; }
  public function hasTimestamp() { return $this->timestamp !== null; }
  public function getTimestamp() { if($this->timestamp !== null) return $this->timestamp; else return null;}
  public function setTimestamp(PbSystemDateTime $value) { $this->timestamp = $value; }

  public function clearFix() { $this->fix = null; }
  public function hasFix() { return $this->fix !== null; }
  public function getFix() { if($this->fix !== null) return $this->fix; else return PbLocation_Fix::FIX_NONE;}
  public function setFix($value) { $this->fix = $value; }

  public function clearSatellites() { $this->satellites = null; }
  public function hasSatellites() { return $this->satellites !== null; }
  public function getSatellites() { if($this->satellites !== null) return $this->satellites; else return 0;}
  public function setSatellites($value) { $this->satellites = $value; }

  public function __toString() {
    return ''
         . Protobuf::toString('latitude', $this->latitude, 0)
         . Protobuf::toString('longitude', $this->longitude, 0)
         . Protobuf::toString('timestamp', $this->timestamp, null)
         . Protobuf::toString('fix', $this->fix, PbLocation_Fix::FIX_NONE)
         . Protobuf::toString('satellites', $this->satellites, 0);
  }

  // @@protoc_insertion_point(class_scope:PbLocation)
}

// message PbSensorOffline
final class PbSensorOffline extends ProtobufMessage {

  private $_unknown;
  private $startIndex = null; // required uint32 start_index = 1
  private $stopIndex = null; // required uint32 stop_index = 2

  public function __construct($in = null, &$limit = PHP_INT_MAX) {
    parent::__construct($in, $limit);
  }

  public function read($fp, &$limit = PHP_INT_MAX) {
    $fp = ProtobufIO::toStream($fp, $limit);
    while(!feof($fp) && $limit > 0) {
      $tag = Protobuf::read_varint($fp, $limit);
      if ($tag === false) break;
      $wire  = $tag & 0x07;
      $field = $tag >> 3;
      switch($field) {
        case 1: // required uint32 start_index = 1
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->startIndex = $tmp;

          break;
        case 2: // required uint32 stop_index = 2
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->stopIndex = $tmp;

          break;
        default:
          $limit -= Protobuf::skip_field($fp, $wire);
      }
    }
    if (!$this->validate()) throw new \Exception('Required fields are missing');
  }

  public function write($fp) {
    if (!$this->validate())
      throw new \Exception('Required fields are missing');
    if (!is_null($this->startIndex)) {
      fwrite($fp, "\x08", 1);
      Protobuf::write_varint($fp, $this->startIndex);
    }
    if (!is_null($this->stopIndex)) {
      fwrite($fp, "\x10", 1);
      Protobuf::write_varint($fp, $this->stopIndex);
    }
  }

  public function size() {
    $size = 0;
    if (!is_null($this->startIndex)) {
      $size += 1 + Protobuf::size_varint($this->startIndex);
    }
    if (!is_null($this->stopIndex)) {
      $size += 1 + Protobuf::size_varint($this->stopIndex);
    }
    return $size;
  }

  public function validate() {
    if ($this->startIndex === null) return false;
    if ($this->stopIndex === null) return false;
    return true;
  }

  public function clearStartIndex() { $this->startIndex = null; }
  public function hasStartIndex() { return $this->startIndex !== null; }
  public function getStartIndex() { if($this->startIndex !== null) return $this->startIndex; else return 0;}
  public function setStartIndex($value) { $this->startIndex = $value; }

  public function clearStopIndex() { $this->stopIndex = null; }
  public function hasStopIndex() { return $this->stopIndex !== null; }
  public function getStopIndex() { if($this->stopIndex !== null) return $this->stopIndex; else return 0;}
  public function setStopIndex($value) { $this->stopIndex = $value; }

  public function __toString() {
    return ''
         . Protobuf::toString('start_index', $this->startIndex, 0)
         . Protobuf::toString('stop_index', $this->stopIndex, 0);
  }

  // @@protoc_insertion_point(class_scope:PbSensorOffline)
}

// message PbVolume
final class PbVolume extends ProtobufMessage {

  private $_unknown;
  private $volume = null; // required uint32 volume = 1

  public function __construct($in = null, &$limit = PHP_INT_MAX) {
    parent::__construct($in, $limit);
  }

  public function read($fp, &$limit = PHP_INT_MAX) {
    $fp = ProtobufIO::toStream($fp, $limit);
    while(!feof($fp) && $limit > 0) {
      $tag = Protobuf::read_varint($fp, $limit);
      if ($tag === false) break;
      $wire  = $tag & 0x07;
      $field = $tag >> 3;
      switch($field) {
        case 1: // required uint32 volume = 1
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          if ($tmp < Protobuf::MIN_UINT32 || $tmp > Protobuf::MAX_UINT32) throw new \Exception('uint32 out of range');$this->volume = $tmp;

          break;
        default:
          $limit -= Protobuf::skip_field($fp, $wire);
      }
    }
    if (!$this->validate()) throw new \Exception('Required fields are missing');
  }

  public function write($fp) {
    if (!$this->validate())
      throw new \Exception('Required fields are missing');
    if (!is_null($this->volume)) {
      fwrite($fp, "\x08", 1);
      Protobuf::write_varint($fp, $this->volume);
    }
  }

  public function size() {
    $size = 0;
    if (!is_null($this->volume)) {
      $size += 1 + Protobuf::size_varint($this->volume);
    }
    return $size;
  }

  public function validate() {
    if ($this->volume === null) return false;
    return true;
  }

  public function clearVolume() { $this->volume = null; }
  public function hasVolume() { return $this->volume !== null; }
  public function getVolume() { if($this->volume !== null) return $this->volume; else return 0;}
  public function setVolume($value) { $this->volume = $value; }

  public function __toString() {
    return ''
         . Protobuf::toString('volume', $this->volume, 0);
  }

  // @@protoc_insertion_point(class_scope:PbVolume)
}

// enum PbStrideSensorCalibSettings.PbStrideCalibType
abstract class PbStrideSensorCalibSettings_PbStrideCalibType extends ProtobufEnum {
  const STRIDE_CALIB_MANUAL = 0;
  const STRIDE_CALIB_AUTO = 1;

  public static $_values = array(
    0 => "STRIDE_CALIB_MANUAL",
    1 => "STRIDE_CALIB_AUTO",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// enum PbStrideSensorCalibSettings.PbRunningFactorSource
abstract class PbStrideSensorCalibSettings_PbRunningFactorSource extends ProtobufEnum {
  const RUNNING_FACTOR_SOURCE_DEFAULT = 0;
  const RUNNING_FACTOR_SOURCE_AUTO_CALIBRATION = 1;
  const RUNNING_FACTOR_SOURCE_MANUAL_CALIBRATION = 2;

  public static $_values = array(
    0 => "RUNNING_FACTOR_SOURCE_DEFAULT",
    1 => "RUNNING_FACTOR_SOURCE_AUTO_CALIBRATION",
    2 => "RUNNING_FACTOR_SOURCE_MANUAL_CALIBRATION",
  );

  public static function isValid($value) {
    return array_key_exists($value, self::$_values);
  }

  public static function toString($value) {
    checkArgument(is_int($value), 'value must be a integer');
    if (array_key_exists($value, self::$_values))
      return self::$_values[$value];
    return 'UNKNOWN';
  }
}

// message PbStrideSensorCalibSettings
final class PbStrideSensorCalibSettings extends ProtobufMessage {

  private $_unknown;
  private $runningFactor = null; // required float running_factor = 1
  private $calibType = null; // required .PbStrideSensorCalibSettings.PbStrideCalibType calib_type = 2
  private $runningFactorSource = null; // optional .PbStrideSensorCalibSettings.PbRunningFactorSource running_factor_source = 3 [default = RUNNING_FACTOR_SOURCE_DEFAULT]

  public function __construct($in = null, &$limit = PHP_INT_MAX) {
    parent::__construct($in, $limit);
  }

  public function read($fp, &$limit = PHP_INT_MAX) {
    $fp = ProtobufIO::toStream($fp, $limit);
    while(!feof($fp) && $limit > 0) {
      $tag = Protobuf::read_varint($fp, $limit);
      if ($tag === false) break;
      $wire  = $tag & 0x07;
      $field = $tag >> 3;
      switch($field) {
        case 1: // required float running_factor = 1
          if($wire !== 5) {
            throw new \Exception("Incorrect wire format for field $field, expected: 5 got: $wire");
          }
          $tmp = Protobuf::read_float($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_float returned false');
          $this->runningFactor = $tmp;

          break;
        case 2: // required .PbStrideSensorCalibSettings.PbStrideCalibType calib_type = 2
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          $this->calibType = $tmp;

          break;
        case 3: // optional .PbStrideSensorCalibSettings.PbRunningFactorSource running_factor_source = 3 [default = RUNNING_FACTOR_SOURCE_DEFAULT]
          if($wire !== 0) {
            throw new \Exception("Incorrect wire format for field $field, expected: 0 got: $wire");
          }
          $tmp = Protobuf::read_varint($fp, $limit);
          if ($tmp === false) throw new \Exception('Protobuf::read_varint returned false');
          $this->runningFactorSource = $tmp;

          break;
        default:
          $limit -= Protobuf::skip_field($fp, $wire);
      }
    }
    if (!$this->validate()) throw new \Exception('Required fields are missing');
  }

  public function write($fp) {
    if (!$this->validate())
      throw new \Exception('Required fields are missing');
    if (!is_null($this->runningFactor)) {
      fwrite($fp, "\x0d", 1);
      Protobuf::write_float($fp, $this->runningFactor);
    }
    if (!is_null($this->calibType)) {
      fwrite($fp, "\x10", 1);
      Protobuf::write_varint($fp, $this->calibType);
    }
    if (!is_null($this->runningFactorSource)) {
      fwrite($fp, "\x18", 1);
      Protobuf::write_varint($fp, $this->runningFactorSource);
    }
  }

  public function size() {
    $size = 0;
    if (!is_null($this->runningFactor)) {
      $size += 5;
    }
    if (!is_null($this->calibType)) {
      $size += 1 + Protobuf::size_varint($this->calibType);
    }
    if (!is_null($this->runningFactorSource)) {
      $size += 1 + Protobuf::size_varint($this->runningFactorSource);
    }
    return $size;
  }

  public function validate() {
    if ($this->runningFactor === null) return false;
    if ($this->calibType === null) return false;
    return true;
  }

  public function clearRunningFactor() { $this->runningFactor = null; }
  public function hasRunningFactor() { return $this->runningFactor !== null; }
  public function getRunningFactor() { if($this->runningFactor !== null) return $this->runningFactor; else return 0;}
  public function setRunningFactor($value) { $this->runningFactor = $value; }

  public function clearCalibType() { $this->calibType = null; }
  public function hasCalibType() { return $this->calibType !== null; }
  public function getCalibType() { if($this->calibType !== null) return $this->calibType; else return PbStrideSensorCalibSettings_PbStrideCalibType::STRIDE_CALIB_MANUAL;}
  public function setCalibType($value) { $this->calibType = $value; }

  public function clearRunningFactorSource() { $this->runningFactorSource = null; }
  public function hasRunningFactorSource() { return $this->runningFactorSource !== null; }
  public function getRunningFactorSource() { if($this->runningFactorSource !== null) return $this->runningFactorSource; else return PbStrideSensorCalibSettings_PbRunningFactorSource::RUNNING_FACTOR_SOURCE_DEFAULT;}
  public function setRunningFactorSource($value) { $this->runningFactorSource = $value; }

  public function __toString() {
    return ''
         . Protobuf::toString('running_factor', $this->runningFactor, 0)
         . Protobuf::toString('calib_type', $this->calibType, PbStrideSensorCalibSettings_PbStrideCalibType::STRIDE_CALIB_MANUAL)
         . Protobuf::toString('running_factor_source', $this->runningFactorSource, PbStrideSensorCalibSettings_PbRunningFactorSource::RUNNING_FACTOR_SOURCE_DEFAULT);
  }

  // @@protoc_insertion_point(class_scope:PbStrideSensorCalibSettings)
}

